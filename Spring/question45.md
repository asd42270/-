### 트랜잭션에 대해서 설명해주세요.
트랜잭션에 대해서 다시!!! 학습하자! Spring Data Jpa에 대해서 강의를 듣던 중 트랜잭션 전파!에 대해서 자세히 알아야겠다 싶어서 이왕 다시 알아보는거 트랜잭션부터 찬찬히 알아봐야겠다 싶었다.

#### 트랜잭션이 뭐게요~
- 기본적인 정의는 더 이상 쪼갤 수 없는 작업의 최소 단위를 말한다. 무결성과 정합성을 유지하기 위한 하나의 논리적 개념.
- 작업의 범위를 말한다고 생각하면 된다.
#### 특징
- 그 유명한 ACID이다.
  - A(Atomicity, 원자성): 하나의 트랜잭션은 모두 데이터베이스에 반영되던지, 모두 안 되던지 해야 한다. 하나의 트랜잭션 내에서 모든 작업이 종료되면 해당 데이터베이스에 commit을 통해서 데이터베이스에 반영한다. 이 때 모두 반영되어야 한다! 만약 작업 중 하나라도 정상적으로 처리되지 못하면 rollback되어 이전에 성공한 결과도 반영되지 않는다.
  - C(Consistency, 일관성): 트랜잭션의 작업 결과는 항상 일관성이 있어야 한다. 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 기존 트랜잭션이 진행됐던 데이터베이스에서 진행되어야 한다.
  - I(Isolation, 독립성): 각각의 트랜잭션은 독립적이다. 다른 트랜잭션이 작업에 관여할 수 없다.
  - D(Durability, 영구성): 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 반영된다.

#### 상태
- 트랜잭션의 진행 과정을 상태를 통해서 표현한 그림이 있길래 가져왔다.
![image](https://github.com/user-attachments/assets/826b7868-5951-4463-9cc5-eaeb75f29753)
출처 :https://junghn.tistory.com/entry/DataBase%EA%B8%B0%EC%B4%88-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-Transaction
- 활동: 트랜잭션이 실행 중인 상태, 부분완료: 마지막 연산까지 했고, commit이 되기 직전의 상태, 완료: 트랜잭션이 종료되고, commit된 상태, 실패: 오류가 발생해서 트랜잭션이 중단된 상태, 철회: 트랜잭션이 비정상적으로 종료되어 rollback된 상태

#### JPA에서 
- JPA는 영속성 컨텍스트에서 데이터의 효율적이고 안전한 관리를 위해 트랜잭션의 기능을 가지고 왔다. (쓰기 지연)
- 트랜잭션의 개념을 적용하기 위해서는 EntityManager에서 EntityTransaction을 가져와 트랜잭션을 적용할 수 있다.

#### Spring에서 Transaction
- Spring은 트랜잭션 관리자를 제공한다. @Transactional 어노테이션을 통해서 트랜잭션을 적용할 수 있다!
- 메서드에 걸어주면 메서드 내의 모든 DB 연산을 하나의 트랜잭션으로 묶어주고, 클래스에 걸어주면 클래스 내부의 모든 메서드에 트랜잭션 어노테이션을 걸어준다.
- 그러면 요녀석은 어떻게 이 트랜잭션을 걸어줄 수 있는 걸까?
##### 고 투 디테일
- 놀랍게도 @Transactional은 AOP가 적용되어 있다.
- 그러니까 요런 식이다.
![image](https://github.com/user-attachments/assets/e28604e8-0a7b-44bb-b80e-fe7a044ad685)
출처: https://www.codeusingjava.com/boot/trans/1
- Service 계층이 @Transactional 어노테이션을 적용하면 Controller와 Service 계층 사이에 Proxy 객체가 추가된다.
- 빈 생성 시 @Transactional 어노테이션이 있으면, 해당 빈의 프록시 객체가 빈으로 등록된다.
- 그리고 트랜잭션의 시작, 커밋 or 롤백 과정은 반복적인 코드이기 때문에 이와 관련된 코드들을 분리하였다.
- 트랜잭이 시작되면 해당 트랜잭션이 적용되어 있는 타겟 메서드가 실행이 되고 트랜잭션이 종료된다.

#### 다시 돌아와서
- 이러한 트랜잭션은 조회 기능에서 필수는 아니다. 조회는 데이터의 변경이 발생하는 것이 아니라 단순히 읽기만 하면 되기 때문이다. 그러나 조회의 경우에도 트랜잭션 환경이 필요한 경우가 있을 수 있기 때문에 조회 메서드에서 readOnly = true 옵션을 어노테이션에 부여해주면 좋다.
- 요거를 사용하면 해당 트랜잭션이 변경에 대한 작업을 수행하지 않도록 지정할 수 있어, 무결성을 보장하고, 의도치 않은 데이터 변경을 방지할 수 있다. 그러면 리소스도 절약할 수 있다. 또 동시성 제어에도 도움이 된다고 한다.(이건 나중에 정리!)
- 그런데 모든 읽기 작업에 이 옵션을 부여하게 되면 Lock이라는 접근 제어 방식에 영향을 미칠 수 있다.(이건 다른 파일로 정리!)

#### 영속성 컨텍스트와 트랜잭션의 생명주기
![image](https://github.com/user-attachments/assets/0b210564-6986-4ec7-ab6f-3b15045c3c70)
- 스프링 컨테이너 환경에서는 영속성 컨텍스트와 트랜잭션의 생명주기가 일치한다.
- 트랜잭션이 유지되는 동안은 영속성 컨텍스트도 계속 유지가 되기 때문에 영속성 컨텍스트의 기능을 사용할 수 있다!
- Spring은 어떻게 Service 부터 Repository 까지 Transaction을 유지할 수 있는 걸까나
  
##### 트랜잭션의 전파
- 전파란 트랜잭션이 진행 중일 때 추가 트랜잭션 진행을 어떻게 할 것인지 결정하는 것을 말한다.
- @Transactional의 propagation 옵션으로 전파 옵션을 지정할 수 있다.
- 기본 옵션은 REQUIRED로, 부모 메서드에 트랜잭션이 존재하면 자식 메서드의 트랜잭션은 부모의 트랜잭션에 합류한다.
- 서비스에서 @Transactional을 통해 생긴 트랜잭션이 있고, 서비스 내의 메서드에서 실행되는 Repository의 메서드들도 각각 @Transactional이 있다. 이 때 Repository의 메서드의 트랜잭션은 서비스 내의 메서드의 트랜잭션으로 합류한다는 것이다!
- 이렇게 트랜잭션을 유지 할 수 있는 것이다!
- 다른 옵션으로 REQUIRES_NEW가 있는데, 이거는 트랜잭션을 분리하는 것이다. 자식메서드의 트랜잭션 전파 옵션이 REQUIRES_NEW 이면 별도의 트랜잭션으로 관리되어 별도의 커밋과 롤백이 수행된다.
- 전파를 이해하려면 물리 트랜잭션과 논리 트랜잭션에 대해서 알아두면 좋을 것 같다.

#### 물리, 논리
- 물리 트랜잭션은 말 그대로 실제 트랜잭션을 말한다. 커밋도하고 롤백도 하는 그 트랜잭션이다! 논리 트랜잭션들을 묶어 물리 트랜잭션이라고 부른다.
- 외부 논리 트랜잭션은 밖에 있는 논리 트랜잭션을 말한다.
- 내부 논리 트랜잭션은 물리 트랜잭션 내부에 있는 트랜잭션 중 외부 트랜잭션이 수행되는 도중에 호출되는 트랜잭션으로, 트랜잭션을 종료시킬 수 없고, 하나의 물리 트랜잭션으로 묶인다.
- 스프링에서는
1. 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
2. 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.
요 원칙을 가지고 있다.

아 굉장히 어렵다.


