### Jwt가 뭐게요?
- Json Web Token의 약자라는 당연한 사실~~
- Json 형식을 이용하여 사용자에 대한 속성을 저장한는 claim 기반의 Web Token이라고 한다.
- 사용자 간 정보를 안전하게 전송, 전달하기 위한 방법 중 하나이다.
- HEADER(해싱 알고리즘과 토큰 타입, 기본 세팅).PAYLOAD(데이터-Claim).SIGNATURE 이러한 형식으로 Json 데이터를 하나의 문자열(토큰)로 인코딩한다.
- SIGNATURE는 토큰을 인코딩하거나 유효성을 검증할 때 사용하는 고유한 암호화 코드이다.
헤더와 페이로드를 각각 Base64로 인코딩한 것과 사용자가 지정한 비밀키를 이용해 헤더에서 지정한 알고리즘으 해싱하고 이를 다시 Base64로 인코딩한다.

  - HEADER와 PAYLOAD를 각각 Base64로 인코딩 -> 비밀키와 함께 헤더에 정의한 알고리즘으로 해싱 -> 이를 다시 Base64로 인코딩
- 토큰을 세션이나 쿠키에 저장하여 사용하거나 요청과 응답 헤더에 넣어서 전달하는 방식으로 사용한다.
 
#### Jwt의 특징
- Stateless: 세션이나 쿠키 방식과 달리 별도의 인증 저장소가 필요하지 않다. 서버가 클라이언트의 상태 정보를 별도로 보관하지 않는다!
단지 비밀 키를 통하여 토큰의 유효성을 검증한다.
- 서버의 부하가 줄어든다!
- 하지만 구현이 복잡하고, 생성된 토큰은 만료 전까지 폐기가 불가하다.

#### Jwt in Spring
- 스프링에서 Jwt를 생성하고 전달하고, 유효성을 검증하는 방식은 아래와 같다.
- ex) 로그인 상황일 때: 사용자가 로그인 데이터를 서버로 전달한다. -> 서버는 이를 기반으로 JWT 토큰을 생성한다. -> 토큰을 헤더에 담아서 응답으로 전달한다.
- ex) 로그인을 해야만 가능한 서비스를 사용할 때: 가지고 있는 토큰을 요청 헤더에 넣어 서버로 전달한다. -> 서버는 요청 헤더에서 토큰을 가져와서 헤더와 페이로드를 디코딩한다. ->
디코딩한 값과 서버가 가지고 있는 비밀키 값을 이용하여 다시 SIGNATURE를 만든다. -> 전달된 토큰의 SIGNATURE와 생성한 SIGNATURE를 비교해서 같으면 인증 성공~ 아니라면 실패!
- 이 복잡한 과정을 스프링 시큐리티는 한 줄로 컷이 가능하다. 바로 이렇게!
``` Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token); ```
- 이거 이해하느라 오늘 하루종일을 다 보낸 것 같다.

#### Jwt를 사용했을 때 발생할 수 있는 문제점
1. 헤더의 alg를 none로 했을 때 공격이 가능하다.: 최신 라이브러리를 사용하면 이 문제는 금방 해결할 수 있다.
2. 디코딩이 진짜 쉽다: 웹사이트에서도 할 수 있다. 그래서 중요한 정보를 넣기 보다는 최소한의 정보만 넣는 것이 좋다.
3. 시크릿키 문제: 시크릿키가 너무 짧으면 해킹 당할 수 있다. 브루트-포스 어택이라고 하는데 짧으면 이 공격에 당할 수 있다.
키를 매우 길게 설정하거나, 키를 공유하지 말고, 생성용 키와 검증용 키 2개를 사용하는 방식도 있다.
4. 토큰 탈취: 이거는 뭐 사용자 문제지 않을까? 이를 방지하기 위해서 서버에서 탈취가 어렵게 만들면 된다!
  - 토큰의 블랙리스트를 만들어서 토큰을 검증할 때마다 블랙리스트도 확인한다. 근데 이거는 세션 사용하는 것과 다를 바 없다.
  - 유효기간을 짧게 한다: 유효 기간이 만료된 토큰은 다시는 사용할 수 없다. 그래서 유효기간이 긴 Refresh Token이라는 것을 사용해서, Refresh Token이 있으면 재발급이 가능하도록 조치한다.
    - 근데 Refresh Token이 탈취 당하면?  Refresh Token Rotation이라는 방법이 있다. Refresh Token 마저 짧게 유지하여 재사용 불가능 하게 만드는 방법이다.
   
이론 대비 코드 구현은 굉장히 쉬운 것 같다. 그런데 이론이 진짜 뭐 이렇게 어려운지.... 파생되는 공부거리도 많은 것 같다..오늘은 여기까지!
    - 
